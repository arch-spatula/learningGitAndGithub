# Sourcetree 설치

수업은 한글로 합니다. 수업 끝나면 영어로 바꾸기를 권장합니다. git 커맨드를 조금이라도 더 익숙해지도록 하십시오.

# Git 은 뭐고, GitHub 은 무엇인가?

`git`은 버전관리 소프트웨어입니다.

git의 변경을 사항을 보고 히스토리라고 합니다.

작업 내역을 저장하는 기준을 보고 commit이라고 합니다.

GitHub는 원격 저장소를 제공해주는 서비스입니다. git으로 커뮤니티 기능도 활용할 수 있습니다. 본인 코드도 올리고 남의 코드도 가져올 수 있습니다.

이슈도 추가할 수 있고 토론도 가능합니다.

다른 사람 프로젝트, 기술, 주제도 볼 수 있습니다.

Sourcetree는 git을 쉽게 사용할 수 있게 해주는 소프트웨어 입니다. Sourcetree는 생각보다 많이 사용합니다. git 중급자까지 커버할 수 있습니다. 하지만 CLI는 초보자를 위한 바퀴가 될 것입니다.

git은 소프트웨어 엔지니어가 사용하는 산업 표준도구입니다. 협업 방법을 모르는 것은 사바사이지만 사용을 모르면 욕박힙니다.

버그 리포트도 github에서도 사용합니다.

이런 프로젝트들도 존재합니다.

[대한민국 헌법 개정이력 프로젝트](https://github.com/ohahohah/constitution-of-republic-of-korea)

[모던 자바스크립트 튜토리얼](https://github.com/javascript-tutorial/ko.javascript.info)

[주니어 개발자를 위한 취업 정보](https://github.com/jojoldu/junior-recruit-scheduler)

[개발자, 채용 가이드북](https://github.com/innovationacademy-kr/tech-hr)

[pyconkr-script](https://github.com/pythonkr/pyconkr-script)

[tacofancy](https://github.com/dansinker/tacofancy)

# 버전관리와 커밋

git은 버전관리 소프트웨어 입니다. 다른 직업과 다르게 `이름_날짜` 방식 파일링하지 않습니다. 버전관리는 커밋으로 관리합니다.

커밋은 엄밀하게 버전을 중간에 저장하는 것이 아닙니다. 프로젝트에 대한 스냅샷입니다. 상태를 저장합니다. 어떤 부분이 변경되었는지 저장하는 게 아닙니다.

# 버전관리와 commit - 실습 01

프로그래밍 할 때는 특수문자가 없어야 합니다. 띄어쓰기는 특수문자입니다. 케밥케이스, 스네이크케이스를 적극적으로 활용합시다.

프로그래밍은 데이터를 관리하는 일입니다. 관리하는 첫 걸음은 이름을 잘 짓는 것입니다.

`command` + `shift` + `.`: mac 에서 숨김파일 보기

보통 파일은 `.`으로 시작하는 파일은 모두 숨깁니다.

디렉토리랑 리포이름은 통일하는게 국룰입니다. 안하면 혼란스럽습니다. 따로 할 수 있지만 굳이 고생하지 맙시다.

코드를 수정하고 에러가 발생하면 git을 사용하면 에러를 추적 꽤 간편해집니다. 이전 이후 변화를 차이로 피드백을 돌려줍니다. 생긴 부분은 `+` 삭제된 부분은 `-`으로 표시해줍니다.

커밋 메시지는 의미가 있어야 합니다. 누가 나중에 보면 본인 아닌 사람이 복구할 수 있어야 합니다.

실무에서는 여러 파일을 한번에 수정하는 경우가 많습니다.

커밋할 때는 업데이트랑, 생성을 모두 올리기보단 업데이트 커밋 파일 따로 생성 커밋 따로 진행하기를 권장합니다.

수정된 파일 중 일부만 커밋하는 경우는 많습니다.

git의 태생이 리눅스를 만드는 과정에 생겨났습니다. git을 잘 사용해야 협업을 잘 할 수 있습니다. 그래서 커밋 메시지를 잘 작성하도록 합니다.

커밋 메시지는 개발자마다 다릅니다. 개발자간 커뮤니케이션은 커밋메시지로 합니다.

프로그래밍은 암기력 배틀이 아닙니다. 문제해결입니다. 어떤 전략으로 문제를 해결할지 초점을 잘 맞추도록 합니다.

# 연습문제

저의 답안

1. 버전관리를 한다는 건 어떤 의미일까?
   작업한 파일들의 변화단위로 저장하는 것입니다.
2. 작업내역 단위인 commit 에는 어떤 정보가 포함되어 있어야 잘 버전관리를 할 수 있을까?
   작업한 파일이름에 어떤 종류의 수정을 했는지 알려줘야 합니다.
3. 지금까지 우리가 실습은 어떤 순서로 했었지?
   add -> commit

선생님이 제공하는 정답

1. 버전관리를 한다는 건 어떤 의미일까?
   - 프로젝트 상태가 변경되는 정보를 알고 있다는 것입니다. Git 은 누가, 언제, 해당 시점의 프로젝트 상태를 기록해두기 때문에 버전 관리가 가능합니다.
2. 작업내역 단위인 commit 에는 어떤 정보가 포함되어 있어야 잘 버전관리를 할 수 있을까?
   - 누가, 언제, 무엇을 했는지가 필요하겠죠? 어떤 작업을 했는지 알려주는 작업 내역인 commit 메시지, 누가(author), commit 한 시간이 필요해요.
   - 그리고 commit 을 편하게 관리하기 위한 commit 아이디! commit 아이디는 사용자 아이디처럼 commit 에 부여된 유일한 값!
3. 지금까지 우리가 실습은 어떤 순서로 했었지?
   - 기존의 프로젝트를 git 프로젝트로 만든다. - git 초기화(git initialize)
   - commit 할 파일들을 add(staging) 하고 commit 메시지 작성해서 commit!

# 원격 repo

원격 repo는 개발자 커뮤니티 역할도 합니다. 하지만 핵심 기능은 클라우드에 작업내역을 호스팅하는 것입니다.

원격과 로컬 리포를 연결하는 것을 보고 추적이라고 합니다. 추적 단위는 브랜치단위로 합니다.

작업은 로컬 리포를 기준으로 생각하는 것도 좋습니다. `git push`는 로컬에서 원격으로 작업 내역을 보냅니다. `git pull`은 원격의 작업 내역을 로컬로 가져오는 명령입니다.

처음으로 `git pull` 명령하기는 어렵습니다. 그래서 하는 명령은 `git clone`입니다.

# 팁

혼자 Git 프로젝트 작업을 할 때는 pull -> 로컬 repo commit -> push 순서로 하면 좋아요.

#

git clone을 하면 원격리포의 커밋 상태도 복사해서 로컬로 가져옵니다.

# 원격 리포 정리하기

1. 원격 repo 와 로컬 repo 를 연결해서 내용을 반영하고 싶을 땐 어떤 방법을 써야할까?
   - `git add` -> `git commit` -> `git push`합니다. 그리고 원격리포에 들어가서 반영 여부를 확인합니다.
   - 예시답안: 로컬 repo 가 없고 원격 repo 에 있는 내용을 가져오고 싶을 때는 clone 한다.
   - 예시답안: 원격 repo 와 로컬 repo 둘 다 있고 두 개를 연결하고 싶을 때는 로컬 repo 가 원격 repo를 tracking 하도록 설정한다.
2. 원격 repo 와 로컬 repo 는 왜 따로 있을까?
   - 협업하기 위해 공유하는 코드베이스를 올려 놓기 위해 따로 둡니다.
   - 협업할 때, 혹은 여러 컴퓨터를 사용한다면 하나의 원격 repo 에 여러 로컬 repo 를 연결시킬 수 있다. 하나의 프로젝트를 동시에 작업하는게 가능해진다.
3. push 와 pull 의 개념을 원격 repo와 로컬 repo 를 포함해 그림으로 그려보세요.
   - 원격 - `pull` -> 로컬 - `commit` -> 로컬 - `push` -> 원격

프로그래밍도 개념지도를 그려보기를 권장합니다.

1. 관련된 자료 없이 그냥 그려보도록 합니다.
2. 그리고 보고 정리합니다.
3. 키워드 보고 보완하고 정리합니다. 마지막에는

# 정리

git과 github는 버전관리, 협업관리, 형상관리도 할 수 있습니다.

# 숙제 링크

[TIL 링크](https://github.com/arch-spatula/TIL)

키워드

- 버전 관리
- git 초기화 (initialize, init)
- add / staging
- commit (커밋)
- commit 내역(history)
- push
- pull
- clone
- tracking

# 이슈할당

이슈마다 작업을 할당합니다. 각각의 개별적인 작업공간인 브랜치에서 진행합니다. 브랜치를 합치는 것을 보고 `merge`라고 합니다. `merge`하기 전에는 `Pull request`를 하게됩니다. `Pull request`를 통해서 코드 리뷰를 진행하게 됩니다.

Issue는 누가 작업을 할지를 정하는 것부터 시작합니다. 이슈는 프로젝트에서 해결해야 하는 문제를 말합니다. 신기능부터 버그픽스 같은 다양한 문제들인 작업 단위들입니다.

Pull request는 제안 사항입니다. 코드를 반영할지 말지 제안합니다.

이슈트레커는 github 외부의 도구들을 활용할 때도 있습니다. Jira도 하나의 예시입니다.

이슈를 만들면 이슈번호를 할당받습니다. 이슈를 기준으로 프로젝트에 판별합니다. 커밋 메시지에 어떤 관계가 있는지 남길 수 있습니다. 이슈는 해결되면 close할 수 있습니다. 하지만 PM이 요청을 번복하면 역으로 open도 할 수 있습니다. 혼자할 때도 이슈를 활용하는게 더 정리가 잘되고 좋습니다.

```shell
git commit "김치째개 육수 요리법 업데이트 #1"
```

뒤에 (#이슈번호)로 연관된 이슈에 연관된 업데이트를 할 수 있습니다.

# Branch

브랜치는 각자 작업영역이자 기능 단위로 나눌 때 사용합니다. 나뭇가지가 뻗어나갈 때 사용합니다.

하나의 브랜치로 작업하면서 DevOps같은 거는 전혀 모르면 참사가 일어날 것입니다. 각자 작업을 하고 적당한 타이밍에 합치는 방식으로 작업을 진행합니다.

```shell
feature/2_jjigea
```

`feature`는 브랜치 종류입니다. `2`는 이슈번호입니다. 마지막 `jjigea`가 의미적인 이름입니다.

![checkout](<../img/image%20(7).png>)

원이 표시된 곳이 `checkout` 상태입니다.

브랜치를 삭제한다는 것은 그동안의 브랜치에 있는 모든 커밋이 다 사라집니다. 그래서 약간은 조심해야 합니다.

브랜치를 삭제할 때는 삭제가 아닌 브랜치를 `checkout` 중인 상태에서 할 수 있습니다.

# Merge

브랜치와 브랜치를 합치는 것을 보고 merge라고 합니다. 모두 통합될 기준 브랜치 등을 용도별로 작업을 합니다.

브랜치를 나누고 커밋하고 합치는 다양한 전략들이 있습니다. 웹은 github flow를 많이 사용합니다.

[github flow](https://docs.github.com/en/get-started/quickstart/github-flow)

웹분야는 업데이트가 괜장히 빠르기 때문에 익숙해져야 할 협업 방법입니다.

`merge commit` 합치고 새로운 커밋을 생성하는 것입니다.

프로그래밍 중에 강제라는 말이 나와있으면 조심할 필요가 있습니다.

실제 협업에서는 브랜치 여러개를 많이 합칩니다.

실제 프로젝트는 항상 이슈부터 만들고 작업을 진행합니다. 이슈를 만들고 작업을 진행하면 설계실력을 늘릴 수 있습니다.

브랜치마다 다른 파일을 수정하도록 합니다. 같은 파일을 수정하면 `merge conflict`가 발생할 것입니다.

# merge conflict

에러를 안내는 것보다는 발생한 버그를 고치는 것이 더 중요합니다.

> 그러나 컴퓨터 프로그래밍을 배울 때 처음부터 잘하지는 못한다. 능숙한 프로그래머가 되려면 능숙하게 '버그'를 찾아내고 수정하는 법을 익혀야 한다. 프로그래밍을 하면서 던져야할 질문은 이것이 맞느냐 틀리느냐가 아니라 버그를 수정할 수 있느냐 없느냐다. 이런 식의 지적 결과물을 바라보는 방식이 지식과 지식 습득을 대하는 좀 더 큰 문화에까지 보편화된다면 우리 모두 '틀리는 것'을 덜 두려워하게 될 것이다.
>
> - 마인드스톰 mindstorm (시모어 패퍼트 지음.인사이트.이현경 옮김)

에러는 반드시 발생할 것이고 어떻게 해결할지가 중요합니다.

`merge conflict`는 양쪽에서 같은파일의 내용이 다를 때 발생합니다. 어느것이 올바른지 해결해달라고 요청하는 것입니다.

`merge conflict`는 인간이 판단하고 결정해야 합니다. 어느것이 오를지는 봐야합니다. 수정은 2중 1택 방식이 아닙니다. 하지만 없던 내용을 추가하는 것은 곤란합니다. 새로운 내용을 추가하고 싶으면 기존 내용을 커밋하고 새로운 내용은 따로 커밋하도록 합니다.

`merge conflict`를 해결하면

```txt
Merge branch 'feature/jjigae_rtan' into main

* feature/jjigae_rtan:
  복쪽의 김씨왕조 김치찌개 레시피 추가

# Conflicts:
#	jjigae.txt
```

이런 커밋 메시지가 자동 완성되어 있을 것입니다. `merge conflict`를 해결한 커밋을 할 준비가 된 것입니다.

에러가 심하면 `brach`를 삭제하면 됩니다. `table drop`에 비하면 덜 부끄럽습니다.

# 원격 repo 와 Branch

원격 `repo`는 놀랍게도 `branch` 단위로 추적합니다. `origin/`이 이름의 접두어로 붙어있으면 원격 리포를 의미합니다.

`git pull`, `git push`는 브랜치 단위로 통신하는 것입니다.

`Pull Request`는 작업한 내용을 리뷰하고 최종적으로 프로젝트에 반영하는 것입니다. 이것은 `PR` 후 `merge`입니다.

![원격리포랑 로컬리포 추적](<../img/image%20(1).jpeg>)

> 지금 상황과 상관없이 여러분은 언제나 더 나아질 수 있다.
> 더 나아지는 일은 언제나 스스로부터 시작할 수 있다.
> 더 나아지는 일은 언제나 오늘부터 시작할 수 있다.
>
> No matter the circumstances you can always improve.
> You can always start improving with yourself.
> You can always start improving today.
>
> - 익스트림 프로그래밍(2판).켄트 벡, 신시아 안드레스 지음. 김창준,정지호 옮김.인사이트

## 정리

협업 순서

1. 이슈
2. 브랜치
3. 머지
4. PR

브랜치는 작업 이름과 의미가 통하게 작명합니다. 작업을 완료하면 브랜치를 삭제하도록 합니다. 안하면 나중에 혼선이 크게 생깁니다.

# 3주차

PR, commit 되돌리기 - amend, revert, reset , 작업내역 임시 저장 - stash
commit 메시지 컨벤션, gitignore, README
github exprore , 오픈소스(open source)
github profile , repo 소개 , github page

# Pull Request

PR은 merge 요청입니다. 코드를 리뷰하고 검토하면서 코드 개선을 하는 과정입니다. 프로젝트 품질, 코드 품질을 관리할 수 있습니다. 큰 merge는 PR을 거칩니다.

PR은 GitHub 웹에서 처리하기를 권장합니다.

PR은 브랜치 단위입니다. PR를 생성한 상태에서 `commit`하고 push하면 원격의 PR은 살아있고 추가 `commit`까지 반영됩니다.

원격에서 작업이 끝나면 웹에서 브랜치를 삭제하는게 편합니다.

PR은 리뷰를 포함합니다. 보통 수정요청이 받드시 들어옵니다. 수정 전에 브랜치를 삭제하면 당연히 곤란합니다.

다른 사람이 소유하고 있는 원격 리포를 복사할 때는 fork부터 해야 합니다.

# commit 고치기

## amend

중간에 커밋 실수 하는 사람은 은근히 많습니다. 개별 커밋으로 하기에는 조금 부족하고 수정은 필요할 때가 있습니다. 예를 들어 주석에 오타를 낸 것 같은 경우입니다.

커밋을 되돌릴 때는 본인 혼자 작업하는 브랜치에서만 되돌립니다. 만약에 브랜치가 많이 갈리거나 merge하는 commit에서 되돌리면 큰일 날 수 있습니다.

최신 커밋 고치는 명령은 amend입니다. 다른 커밋은 못 고칩니다.

push 이전에 amend를 할 때는 비교적 간단합니다. 하지만 원격에서 강제 push할 때는 정말 위험합니다. 다른 브랜치에 영향을 주지않는 본인 브랜치에서만 합니다.

강제 push를 하고 수정하는 것도 가능합니다. 하지만 설정을 `git allow force push`로 해야합니다. 하지만 어떤 참사가 발생할지 모르니 주의하도록 합니다.

## revert, reset

최신이 아닌 커밋을 되돌리는 방법도 존재합니다. revert은 commit 기록을 남기고 되돌립니다.

reset은 기록을 되돌립니다. reset 기준 앞의 commit은 모두 삭제됩니다. 기준 커밋상태로 돌아가기 때문에 잘못하면 심각한 문제를 만들 수 있습니다.

## Stash

Stash는 임시보관함입니다. 작업하던 내용을 임시로 보관할 때 사용합니다. 버그가 발생하면 추가기능를 만들어서 고치는 것을 보고 hotfix라고 부릅니다.

커밋하기 전에 다른 브랜치 이동이 필요할 때 유용합니다. 그래서 커밋이 아닌 상태일 때 명령이 가능합니다.

적용해도 되고 삭제해도 됩니다.

완전히 새로운 파일은 추적하지 않습니다. git add을 안했기 때문에 덮어지거나 stash로 보호할 필요가 없습니다. 파일이 add된적이 없으면 브랜치로 할당받은 적도 없기 때문에 branch 변경을 해도 파일이 영향을 받지 않습니다.

git stash는 변경사항을 담아두도록 합니다. 하지만 남용하면 작업을 잊어버릴 수 있습니다.

# 협업

## 커밋 컨벤션

커밋 메시지 컨벤션은 회사마다 조직마다 다릅니다. 커밋 메시지를 대충 작성하면 작업을 오랜 기간 놔버리면 모릅니다.

[좋은 git 커밋 메시지를 작성하기 위한 7가지 약속](https://meetup.toast.com/posts/106)

제목과 본문 1줄 띄웁니다.

한글과 영어는 조금 다릅니다.

본문은 무엇을 왜에 맞추어서 작성합니다.

커밋 메시지도 중요하지만 커밋 단위도 중요합니다. 당연히 사람과 조직마다 다릅니다. 중요한 것은 관된 규칙입니다. 새로운 변경이 버그를 발생시키면 이전 커밋까지 차이가 작으면 수정이 편하다는 것을 알 수 있습니다.

단위가 기능, 이슈, 함수 등 다양한 기준이 될 수 있습니다.

동사를 영어로 작성하고 나머지를 한글로 작성하는 것도 전략입니다. 글로벌 오픈소스가 아니면 한국어로 작성해도 괜찮습니다.

많은 회사들은 영어로 커밋메시지를 작성합니다.

커밋 메시지 템플릿도 활용하는 것이 전략입니다.

```txt
키워드 - 기능, 단위 #issue번호

변경사항 :

# 키워드: 생성, 수정, 추가,고치기,문서화,스타일, 테스트
# "왜", "무엇"을 포함하기
# 제목은 80자 이내로, 긴 내용은 줄바꿈하고 본문에서
```

이슈 번호는 PR할 예정이면 생략해도 괜찮습니다. 하지만 아니면 붙이도록 합니다.

## 코드리뷰

코드리뷰는 사람이 작업한 코드를 리뷰하는 작업입니다. 어떤 개선을 요구합니다. 보통은 기능, 버그, 성능을 중점으로 봅니다.

리뷰가 완료되면 merge하게 됩니다.

코드리뷰를 하는 이유는 첫번째는 코드 품질을 높일 수 있습니다. 본인한테 안 보이는 버그를 다른 사람이 볼 수 있습니다. 배포 전에 작은 버그들 쉽게 찾을 수 있습니다. 피드백을 주면서 더 좋은 해결책도 찾을 수 있습니다. 실력측면에서 상당히 좋습니다.

기술 블로그에서 코드 리뷰에 대해서 올려 놓는 경우가 많습니다.

코드리뷰는 받는 사람도 주는 사람도 모두 도움됩니다.

# gitignore

gitignore는 git이 추적하지 않게 만드는 파일입니다. .gitignore으로 만들면 됩니다. 안에 텍스트파일처럼 입력하면 git은 알아서 무시합니다.

github에 올리면 큰일나는 것들이 있습니다. api key, 비밀번호, 컴퓨터 설정 등이 있습니다. 파이썬 가상환경, 자바 바이트코드 모두 각각 다를 때가 있습니다. 이런 파일들은 안보이게 관리하는 것을 권장합니다.

# README.md

보통 소프트웨어를 설치하면 바로 봐야 하는 것은 `README.md`파일입니다.

# 에러노트

![github access key for userName 에 저장된 비밀정보를 사용하려고 합니다](../img/1623070989037_G5vcVbMxsf.png)

- 원인:
  1.  로컬 리포를 원격 리포로 푸시할 때 발생했습니다.
  2.  맥북에서 보안문제로 돌려준 피드백입니다.
  3.  간단하게 노트북 비번치라고 할 수 있는 것을 다른 정보를 제공하는 것으로 더 어려운 절차를 거처야 할 것 처럼보였습니다. 나쁜 다이얼로그 UX입니다.
  4.  검색도 좋지 않았습니다. [[Sourcetree] git-credential-osxkeychain](https://unttd.cc/zilla/17)

그냥 노트북 비번치라고 말해줄 것이지 꼭 깃헙 계정들어가 키체인 다시 발급받야하게 생겼습니다.

- 해결:
  1.  노트북 비번을 치고 해결했습니다.
